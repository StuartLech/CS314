To implement the GetPID() function, the first thing I noticed was that the trap vector was already assigned the value 0x431 in the traps.h file. This value was defined as TRAP_GETPID. Taking that as a starting point, I extended the usertraps.h file by adding the corresponding assembly code, which looks something like this:
This block of code serves as a user-level trap interface for the GetPID() function, utilizing the previously defined trap vector.To integrate GetPID() into the kernel, I went to the dointerrupt() function, and within it, I inserted a new case statement to handle TRAP_GETPID. Here, I made a call to the GetPID() function, which is defined in process.c.To pass the GetPID() result back to the user program, I utilized the ProcessSetResult() function. This function is designed to take two arguments: the first is a pointer to the current Process Control Block (PCB), and the second is the result value to be returned. In this case, the value returned is obtained by invoking GetPID().I noticed that in the codebase, every time ProcessSetResult() is called within dointerrupt(), it is always followed by RestoreIntrs(intrs);. Although I was not entirely sure about its purpose, I followed the existing pattern and included it as well. Lastly, to complete the implementation, I declared GetPID() in process.h as returning an integer and then defined it in process.c. For calculating the Process ID, I looked into how ProcessFork() returns the process number. It essentially subtracts the starting address of the specific PCB from the base address of the array that contains all PCBs (pcbs[]). So, in GetPID(), I returned the difference between the currentPCB pointer and the base address of pcbs, and typecast it to an integer. By following these steps, I was able to successfully implement the GetPID() function.




